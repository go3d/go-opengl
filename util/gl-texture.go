package ugl

import (
	"image"
	"reflect"

	gl "github.com/go3d/go-opengl/core"
)

//	Implemented by specialized texture types such as Texture2D.
type Texture interface {
	Dispose()

	//	Deletes and (re)creates the texture object based on its current params.
	Recreate() error
}

//	Embedded by specialized texture types such as Texture2D.
type TextureBase struct {
	//	The OpenGL handle for this texture object.
	//	This is 0 before calling Recreate() and after calling Dispose().
	GlHandle gl.Uint

	//	The type of texture, such as for example gl.TEXTURE_2D.
	GlTarget gl.Enum

	//	Specifies the sized internal format to be used to store texture image data,
	//	as per gl.TexStorageNN(). Defaults to gl.RGBA8.
	SizedInternalFormat gl.Enum

	//	If true, then (if Support.Textures.Immutable is also true) whenever this Texture
	//	is Recreate()d it is declared immutable in OpenGL, meaning its dimensions are
	//	locked at creation time and cannot be changed subsequently.
	//	Defaults to Support.Textures.Immutable.
	Immutable bool

	//	Settings for this texture's MIP map, if any.
	MipMap struct {
		//	If true (the default) and NumLevels isn't 1, all MIP map
		//	levels are automatically generated by Recreate()
		AutoGen bool

		//	The maximum number of MIP map levels for this texture object.
		//	Set to 0 (the default) to have Recreate() determine this
		//	automatically, set to 1 for a texture object with no MIP map.
		NumLevels gl.Sizei
	}

	//	Information regarding the pixel data stored by this texture object.
	PixelData struct {
		//	Specifies the format of the pixel data, as per
		//	gl.TexSubImageNN(). Defaults to gl.RGBA.
		Format gl.Enum

		//	Specifies the data type of the pixel data, as per
		//	gl.TexSubImageNN(). Defaults to gl.UNSIGNED_BYTE.
		Type gl.Enum

		//	Pointers (one per sub-image) to the first pixel
		//	of the data stream to be uploaded by Recreate().
		//	Initially defaults to []gl.Ptr { PtrNil }
		Ptrs [6]gl.Ptr
	}
}

//	Deletes this texture object from OpenGL.
func (me *TextureBase) Dispose() {
	if me.GlHandle != 0 {
		gl.DeleteTextures(1, &me.GlHandle)
		me.GlHandle = 0
	}
}

func (me *TextureBase) immutable() bool {
	return Support.Textures.Immutable && me.Immutable
}

func (me *TextureBase) init() {
	me.MipMap.AutoGen, me.Immutable = true, Support.Textures.Immutable
	me.SizedInternalFormat = gl.RGBA8
	me.PixelData.Format = gl.RGBA
	me.PixelData.Type = gl.UNSIGNED_BYTE
	for i := 0; i < len(me.PixelData.Ptrs); i++ {
		me.PixelData.Ptrs[i] = PtrNil
	}
}

func (me *TextureBase) onAfterRecreate() {
	Cache.BindTextureTo(0, 0, me.GlTarget)
}

func (me *TextureBase) onBeforeRecreate() (err error) {
	if me.immutable() {
		Cache.BindTextureTo(0, 0, me.GlTarget)
		me.Dispose()
		err = Try.GenTextures(1, &me.GlHandle)
	} else if me.GlHandle == 0 {
		err = Try.GenTextures(1, &me.GlHandle)
	}
	if err == nil {
		Cache.BindTextureTo(0, me.GlHandle, me.GlTarget)
	}
	return
}

func (me *TextureBase) prepFromImages(bgra, uintRev bool, images ...image.Image) (err error) {
	pixData, pfmt := &me.PixelData, Typed.Ife(bgra, gl.BGRA, gl.RGBA)
	pixData.Format = pfmt
	pixData.Type = Typed.Ife(uintRev, gl.UNSIGNED_INT_8_8_8_8_REV, gl.UNSIGNED_BYTE)
	for i, img := range images {
		switch pic := img.(type) {
		case *image.Alpha:
			me.SizedInternalFormat = gl.R8
			pixData.Format = gl.RED
			pixData.Ptrs[i] = gl.Ptr(&pic.Pix[0])
		case *image.Alpha16:
			me.SizedInternalFormat = gl.R16
			pixData.Format = gl.RED
			pixData.Ptrs[i] = gl.Ptr(&pic.Pix[0])
		case *image.Gray:
			me.SizedInternalFormat = gl.R8
			pixData.Format = gl.RED
			pixData.Ptrs[i] = gl.Ptr(&pic.Pix[0])
		case *image.Gray16:
			me.SizedInternalFormat = gl.R16
			pixData.Format = gl.RED
			pixData.Ptrs[i] = gl.Ptr(&pic.Pix[0])
		case *image.NRGBA:
			me.SizedInternalFormat = gl.RGBA8
			pixData.Format = pfmt
			pixData.Ptrs[i] = gl.Ptr(&pic.Pix[0])
		case *image.NRGBA64:
			me.SizedInternalFormat = gl.RGBA16
			pixData.Format = pfmt
			pixData.Ptrs[i] = gl.Ptr(&pic.Pix[0])
		case *image.RGBA:
			me.SizedInternalFormat = gl.RGBA8
			pixData.Format = pfmt
			pixData.Ptrs[i] = gl.Ptr(&pic.Pix[0])
		case *image.RGBA64:
			me.SizedInternalFormat = gl.RGBA16
			pixData.Format = pfmt
			pixData.Ptrs[i] = gl.Ptr(&pic.Pix[0])
		case interface {
			Pix() []byte
		}:
			pixData.Ptrs[i] = gl.Ptr(&pic.Pix()[0])
		default:
			err = errf("Unsupported image.Image type (%v) for use as OpenGL texture", reflect.TypeOf(pic))
		}
	}
	return
}

func (me *TextureBase) recreate(numTargets int, initialTarget gl.Enum, maxNumMipLevels, width, height gl.Sizei) (err error) {
	err = me.onBeforeRecreate()
	defer me.onAfterRecreate()
	if err == nil {
		var (
			glTargets               []gl.Enum
			hasPixData, hasAllFaces bool
			i                       int
		)
		min, numLevels := int(initialTarget), me.MipMap.NumLevels
		glTargets = make([]gl.Enum, numTargets)
		for i = 0; i < numTargets; i++ {
			glTargets[i] = gl.Enum(min + i)
		}
		if numLevels < 1 {
			numLevels = maxNumMipLevels
		}
		if me.immutable() {
			err = Try.TexStorage2D(me.GlTarget, numLevels, me.SizedInternalFormat, width, height)
		}
		if hasAllFaces = true; err == nil {
			for i = 0; i < numTargets; i++ {
				if hasPixData = me.PixelData.Ptrs[i] != PtrNil; !hasPixData {
					hasAllFaces = false
				}
				if me.immutable() {
					err = me.subImage(glTargets[i], 0, 0, width, height, me.PixelData.Ptrs[i])
				} else {
					err = me.texImage(glTargets[i], width, height, me.PixelData.Ptrs[i])
				}
			}
		}
		if (err == nil) && hasAllFaces && me.MipMap.AutoGen {
			err = Try.GenerateMipmap(me.GlTarget)
		}
	}
	return
}

func (me *TextureBase) subImage(glTarget gl.Enum, x, y gl.Int, width, height gl.Sizei, ptr gl.Ptr) (err error) {
	if ptr != PtrNil {
		if Support.Textures.StreamUpdatesViaPixelBuffer {
			buf := NewPixelUnpackBuffer()
			defer buf.Dispose()
			buf.Recreate(0, gl.Sizeiptr(width*height*4), PtrNil, gl.STREAM_DRAW)
			buf.Bind()
			defer buf.Unbind()
			pbo := buf.Map(true, true)
			*pbo = gl.Ptr(ptr)
			buf.Unmap()
			err = Try.TexSubImage2D(glTarget, 0, x, y, width, height, me.PixelData.Format, me.PixelData.Type, PtrNil)
		} else {
			err = Try.TexSubImage2D(glTarget, 0, x, y, width, height, me.PixelData.Format, me.PixelData.Type, ptr)
		}
	}
	return
}

func (me *TextureBase) texImage(glTarget gl.Enum, width, height gl.Sizei, ptr gl.Ptr) (err error) {
	err = Try.TexImage2D(glTarget, 0, gl.Int(me.SizedInternalFormat), width, height, 0, me.PixelData.Format, me.PixelData.Type, ptr)
	return
}
